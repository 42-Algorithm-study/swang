# 소수의 판별

**소수(Prime Number)**  
- 2 이상의 자연수 중에서 1과 자기 자신을 제외한 약수가 존재하지 않는 수  
- 2 이상의 자연수 이므로 1은 소수에 해당하지 않음


<br>
<br>


**소수를 판별하는 가장 간단한 방법**  
어떤수 X가 주어졌을 때, X를 2부터 X-1로 모두 나눠 소수임을 판별하기  
```Python
def check_prime_number(X):
    for i in range(2, X):
        if X % i == 0:
            return "NO"
    return "YES"

X = int(input())

print(check_prime_number(X))
```
- 이 코드의 시간 복잡도는 `O(X)`로 1,000,000이라는 수가 소수인지 판별하려면 2부터 999,999까지 모든 수에 대하여 확인을 해야함.  
	-> 매우 비효율적

<br>
<br>


**자연수의 약수가 가지는 특징 파악하기**  
- 약수는 `대칭`적이다
	```
	12의 약수
	[1, 2, 3, 4, 6, 12]의 경우
	{1,12}, {2,6}, {3,4} 로 대칭을 이루고 있음
	9의 약수
	[1,3,9]
	{1,9}, {3, 3}로 대칭을 이루며 3은 9의 제곱근
	```
	-> 자연수 X가 소수인지 확인하기 위해선 `X의 제곱근`까지만 확인하면 됨

<br>
<br>


**개선된 소수판별함수**  
```Python
import math

def check_prime_number(X):
    for i in range(2, int(math.sqrt(X)) + 1):
        if X % i == 0:
            return "NO"
    return "YES"

X = int(input())

print(check_prime_number(X))
```
- `int(math.sqrt(X)) + 1`  
	8의 경우 √8 까지만 체크하면 되는데, √8은 약 2.8로 2까지만 확인하면 된다.  
	(int(math.sqrt(X)) + 1 == 3)이므로 for문에서 2까지 체크가능  

- 반복문에서 제곱근까지만 확인하기 때문에 O(√X)의 시간복잡도를 가진다.  
	1,000,000같은 큰 수도 1,000까지만 확인

<br>
<br>

**하나의 수가 아니라 범위 속 모든 소수를 찾아야 한다면?**
- 아무리 시간복잡도가 O(√X)라고 해도 1부터 1,000,000 사이의 소수를 모두 찾으라고 하면 너무 오래 걸릴 것  
	-> `에라토스테네스의 체 알고리즘`

<br>
<br>
<br>
<br>

# 에라토스테네스의 체  
- 여려 개의 수가 소수인지 아닌지를 판별할 때 사용하는 대표적인 알고리즘
- N보다 작거나 같은 모든 소수를 찾을 때 사용할 수 있음

<br>

**구현 과정**
```
1. 2부터 N까지의 모든 자연수를 나열
2. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다.
3. 남은 수 중에서 i의 배수를 모두 제거한다
	(문제 조건에 따라 i는 제거할수도, 제거하지 않을수도 있음)
4. 더 이상 반복할 수 없을 때까지 2~3과정을 반복한다
```


**에라토스테네스의 체 구현**  
```Python
import math

N = int(input())

arr = [True for _ in range(N + 1)]
# arr[N]이 소수인지 아닌지 정보가 담길 배열 

for i in range(2, int(math.sqrt(N)) + 1):
    if arr[i] == True: # 아직 탐색하지 않은 요소일때
        j = 2 # 1일경우 자기 자신도 False가 됨 (문제 조건에 따라 1 or 2)
        while i * j <= N: # i * j가 N보다 크면 배열인덱스 넘어감
            arr[i*j] = False # i의 배수일 경우 소수가 아님
            j += 1

for i in range(2, N + 1):
# 배열에서 True인 값만 출력 (소수)
    if arr[i]:
        print(i, end=" ")
```
- 에라토스테네스의 체 알고리즘의 시간복잡도는 O(NloglogN)으로 사실상 선형 시간에 가까울만큼 빠름  
- 단점은 배열을 N+1의 크기로 선언하므로 메모리가 많이 필요함  
	-> 10억이 소수인지 판별하기 위해서 에라토스테네스 체를 이용하기엔 비효율적
- 에라토스테네스의 체 알고리즘을 이용해아하는 문제의 경우 N이 1,000,000 이내로 주어지는 경우가 많음.