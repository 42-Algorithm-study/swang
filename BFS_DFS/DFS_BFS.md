## DFS
특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙이 들어가서 노드를 방문한 후, 다시 돌아가 다른 경로로 탐색하는 알고리즘  
(깊이 우선 탐색 : 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘)  


### 그래프
: 노드와 간선으로 표현되며, 노드를 정점이라고도 말함.  


### 그래프를 표현하는 방법
 - 인접 행렬(Adjacency Matrix) : 2차원 배열로 그래프의 연결 관계를 표현하는 방식  
 - 인접 리스트(Adjacency List) : 리스트로 그래프의 연결 관계를 표현하는 방식  


---

### 다음의 그래프를 표현해보자
|-|0|1|2|
|--|--|--|--|
|0|0|7|5|
|1|7|0|INF|
|2|5|INF|0|


```C
1. 인접 행렬 (2차원 배열/C)

int arr[4][4];
a[0][0] = 0;
a[0][1] = 7;
a[0][2] = 5;
a[1][0] = 7;
a[1][1] = 0;
a[1][2] = INF;
a[2][0] = 5;
a[2][1] = INF;
a[2][2] = 0;
```

```python
1. 인접 행렬 (파이썬에서는 배열대신 리스트자료형을 사용)

graph = [
	[0, 7, 5]
	[7, 0, INF]
	[5, INF, 0]
]
```

```python
2. 인접 리스트 (연결된 노드 정보를 저장)
graph = [[] for _ in range(3)]

graph[0].append((1,7))
graph[0].append((2,5))
graph[1].append((0,7))
graph[2].append((0,5))
```

## 인접한 노드 탐색(stack)
```
1. 탐색 시작 노드를 스택에 삽입 + 방문처리
2-1. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 노드를 스택에 삽입 + 방문처리
2-2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 없으면 스택에서 제거
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복
```
<br/>
<br/>

---
### 문제를 풀면서 발견한 점 메모
- 모든 노드가 연결되어 있다는 보장이 없을 때는 조건문에서 `if 0 not in visit`과 같은 옵션은 주의할 것 (0이 방문하지 않은 노드)