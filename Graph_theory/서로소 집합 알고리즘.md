## 서로소 집합 알고리즘  
**서로소 집합(Disjoint Set)**  
- 공통 원소가 없는 두 집합
- 서로소 집합 자료구조는 union과 find 2개의 연산으로 조작할 수 있음  
-> union-find 자료구조라고 불리기도 함

**union-find**  
- union(합집합) 연산은 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
- find 연산은 특정한 원소가 속한 집합이 어떤 집합인가 알려주는 연산
- 스택과 큐가 push, pop 으로 짝을 이뤘던것처럼 서로소 집합 자료구조는 union과 find로 이루어진다.


### 구현
- 트리구조를 이용하기 때문에 번호가 큰 노드가 자식노드, 작은 노드가 부모 노드가 된다.
- union 연산 정보가 주어졌을 때  
union 연산의 대상은 노드, union 연산을 간선을 잇는 과정이라고 생각하면 쉽다.


### 경로 압축 기법(Path Compression)
- find 연산을 통해 부모 노드를 찾을 때  
최악의 경우 부모의 부모의 부모.. 까지 거슬러 올라가야 하므로 최대 O(노드의 개수)의 시간복잡도를 가짐.
- 경로 압축 기법을 이용하여 find를 재귀적으로 호출하여 부모테이블을 갱신하도록 한다.

```python
def _find(i):
  if parent[i] != i: # 자기자신이 루트노드가 아닐 때
    parent[i] = _find(parent[i]) # 부모의 부모를 저장
  return parent[i]
```


**구현할 때 헷갈렸던 점**
```python
def _find(i):
  if parent[i] == i:
    return i
  else:
    parent[i] = _find(parent[i])

# parent 리스트 출력시 [1, 2, None, None, 5, None] 
# 이렇게 None이 나오는 이유는?
```

-> 재귀함수에서 리턴값이 없는 부분이 있어서 None값이 들어감  
-> parent[i] == i 일때와 그렇지 않을 때 모두 parent[i] 를 리턴함  
-> 조건문과 반환값을 수정

```python
def _union(a, b):
  a = _find(a)
  b = _find(b)
  if a < b:
    p[] = a
  else:
    p[a] = b

또는

def _union(a,b):
    A = _find(a)
    B = _find(b)
    if A == B:
        return
    elif A < B:
        p[B] = A
    else:
        p[A] = B
```

-> 부모 노드끼리 비교 후 부모노드의 부모테이블을 갱신 
  하위 노드들은 결국 상위노드의 부모값까지 거슬러 오르게 됨.
-> a와 b의 부모를 가져와서, 그 노드끼리 비교하여 부모를 갱신해주면 된다.
-> 부모의 부모를 갱신!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-> 공간복잡도를 따지자면, 변수를 재사용하는게 좋겠다.


### 사이클 판별

```
1. 모든 간선에 대해 union 연산을 진행 하기 전 **각 노드에 대한 부모노드** 체크  
2-1. 부모 노드가 같은 상태라면 사이클이 형성! (노드를 잇는 순간 사이클이 만들어지므로)  
2-2. 부모 노드가 다르다면 union 연산 수행  
```  

- 간선의 개수가 E개일 때 모든 간선을 하나씩 확인
- 간선에 방향성이 없는 무향 그래프에서만 적용이가능