# 다익스트라 알고리즘 (심화)

## 기본적인 다익스트라 알고리즘의 한계
```python
for _ in range(n - 1): # -> n번 동안 (노드의 개수 == n)
        cheep = get_cheep_node()
        visit[cheep] = True
        for _tuple in graph[cheep]: # -> 방문한 노드와 연결된 노드를 다 탐색 해야함 (cheep 노드가 다른 모든 노드와 연결되어있다면 최대 n번 탐색)
            if d[_tuple[0]] > d[cheep] + _tuple[1]:
                d[_tuple[0]] = d[cheep] + _tuple[1]
```
- O(n)에 걸쳐서, 거리가 가장 짧은 노드가 있는지 탐색
- 시간복잡도는 O(n^2)
-> 전체 노드의 개수가 많아질수록 시간복잡도가 매우 증가함.  

## 다익스트라 알고리즘 개선 방법
- 방문하지 않은 노드 중에서 최단거리가 가장 짧은 노드를 선택하기 위해 힙 자료구조를 이용한다.  
(현재 가장 가까운 노드를 저장하기 위해 힙 자료구조를 추가로 이용, 최단 거리(최소 비용)을 선택해야 하므로 최소 힙을 사용)


## 우선순위 큐를 활용하여 시간복잡도 줄이기

**우선순위 큐(Priority Queue)란?**
- 우선순위가 가장 높은 데이터를 먼저 삭제하는 자료구조  
+) 스택(FILO), 큐(FIFO) 
- Python을 포함한 대부분의 프로그래밍 언어에서 표준 라이브러리 형태로 지원

## 힙(Heap)
- 우선순위 큐를 구현하기 위해 사용하는 자료구조 중 하나
- 최소 힙과 최대 힙  
-> 파이썬에서는 최소 힙만 제공하므로 최대 힙을 사용하고 싶을 때는  
    데이터 삽입시 -부호를 붙여 삽입하고, 데이터를 추출할 때 다시 -부호를 붙여 원상복구 시키는 방식을 이용함.
- 다익스트라 최단 경로 알고리즘을 포함해 다양한 알고리즘에서 사용

</br>

|우선순위 큐 구현 방식| 삽입 시간| 삭제시간||
|--|--|--|--|
|리스트|O(1)|O(N)|리스트의 마지막에 데이터 추가, 리스트를 순회하여 우선순위가 높은 데이터를 삭제|
|힙|O(logN)|O(logN)|트리로 구현되어 있어 삽입과 삭제에 logN의 시간복잡도를 가짐|


# 개선된 구현 방법 성능 분석
\* py 파일에 자세한 주석 참고
```python
def dijkstra(start):
    q = []
    heapq.heappush(q, (0, start))
    d[start] = 0
    while q: 
        cost, dst = heapq.heappop(q)
        if d[dst] < cost:
            continue
        for _tuple in graph[dst]:
            sum_cost = cost + _tuple[1]
            if sum_cost < d[_tuple[0]]:
                d[_tuple[0]] = sum_cost
                heapq.heappush(q, (sum_cost, _tuple[0]))
    # d[node] = 출발지에서 그 노드까지의 최소거리 
    # 그래프에 담겨있는 것 -> (노드, 거리)
    # 힙에넣을떄 -> (거리, 노드)
```

- 반복문 while의 조건이 q가 비어있지 않을 때로 작성되어 있으나  
실제로 알고리즘이 수행되는 경우는 아래의 `if d[dst] < cost` 조건이며  
이 조건에 따라 이미 최단거리가 테이블에 저장되어있는 노드는 재 방문하지 않음.  
(다익스트라 알고리즘에서는 방문하는 순간이 제일 최단거리, 최소비용임)  
\** 다익스트라 알고리즘(기본) 참고

-  `if d[dst] < cost` 조건 아래의 알고리즘이 수행되는 횟수는 방문한 노드별로 연결된 간선만큼 진행함. (_tuple의 개수)  
모든 노드들을 방문하며 간선마다 탐색하기 때문에 최대 간선의 개수 만큼 알고리즘이 수행된다.

- 노드의 개수(V), 간선의 개수(E)일 때  
E개의 원소를 우선순위 큐에 넣었다가 모두 빼내는 연산과 비슷하며, 노드의 개수(V), 간선의 개수(E) 일 때 시간복잡도를 O(ElogE)로 판단할 수 있음.  
-> 중복 간선을 포함하지 않는 경우 노드가 V개 일때 생길 수 있는 전체 간선의 최대 개수는 V^2개 이며,  
O(ElogE) -> O(ElogV^2) -> O(2ElogV) -(계수는 생략...)-> O(ElogV)  
따라서, 개선된 다익스트라 알고리즘은 시간복잡도 O(ElogV)를 가짐.