# 효율적인 화폐 구성
N, M = map(int, input().split())
money = list()

for i in range(N):
    money.append(int(input()))

dp = [-1] * (M + 1)

# 화폐 단위와 똑같은 애들은 1로 초기화
for m in money:
    if (m <= M): # 화폐단위보다 만들어야 하는 금액이 작을 수도 있다
        dp[m] = 1

# 최소 단위 화폐 + 1 부터  인덱스시작 (최소단위 화폐는 어차피 1로 초기화 되어있음)    
min_money = min(money)
for i in range(min_money + 1, M + 1):
    for m in money: # 각 화폐단위를 돌면서
        # 화폐금액이 인덱스보다 큰 경우에도 우연히 잘 돌아가고 있었음! 인덱스 범위를 잘 고려하자.
        if (i - m > 0 and dp[i - m] != -1): # f(m) + f(i-m) 의 점화식을 사용, 단 f(i-m)은 -1이 아니여야 함. (만들 수 있는 금액이어야 함.)
            if (dp[i] == -1): # 현재 dp[i]가 초기화 된 적 없다면, 값을 넣어줌
                dp[i] = dp[m] + dp[i - m]
            else: # 다른 화폐단위에서 초기화 된 적이 있다면 초기화 된 값과 비교하여 더 작은 값을 넣어줌.
                dp[i] = min(dp[i], dp[m] + dp[i - m])
# print(dp)
print(dp[M])

'''
풀이과정

15원을 만들 때, 화폐 금액이 2원, 3원이라고 하자.
dp 테이블은 모두 -1 로 초기화.
화폐 금액과 같은 테이블 인덱스는 1개로 초기화.
2원 3원 바로 다음인 4원 부터 어떻게 만들 수 있는지 계산해야 하는데,
        ->(코드는 최소금액 + 1 인덱스 부터 탐색 : 2원 5원 이렇게 주어지면 3원부터 탐색해야하기 때문)
f(4) = f(2) + f(2) 또는 f(3) + f(1) 처럼 화폐금액 + 화폐금액을 빼고 남은 인덱스의 항을 더해주면 됨

화폐 금액은 리스트에 담겨있으므로 위의 작업을 화폐금액이 담겨있는 리스트만큼 돌린다.
이 때, dp[i]가 초기화 되어있지 않으면(-1의 값을 가진다면), 계산한 값을 넣고
dp[i]가 초기화 되어있다면 새로 계산할 값과 기존 값을 비교하여 더 적은 개수로 갱신한다.
+ 값을 계산할 때 dp[i - m] 이 -1이라면 만들 수 없는 금액이므로 초기화 하지 않아야 함!
'''